<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ì£¼ì‚¬ìœ„ ë³´ë“œê²Œì„ + ë§µ ì—ë””í„°</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 20px;
      background: #f5f5f7;
    }

    h1 {
      text-align: center;
      margin-bottom: 4px;
    }

    .game-container {
      max-width: 900px;
      margin: 0 auto;
      background: #ffffff;
      padding: 16px;
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
      transition: transform 0.15s ease;
      position: relative;
      overflow: hidden;
    }

    .top-panel {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: flex-start;
      justify-content: space-between;
      margin-bottom: 16px;
      position: relative;
      padding-bottom: 12px;
      border-bottom: 1px solid rgba(148, 163, 184, 0.4);
    }

    .top-panel::after {
      content: "";
      position: absolute;
      left: 0;
      bottom: -1px;
      width: 100%;
      height: 2px;
      background: linear-gradient(90deg, #4f46e5, #22c55e, #f97316);
      opacity: 0.9;
    }

    .status-block {
      display: flex;
      flex-direction: column;
      gap: 6px;
      background: rgba(249, 250, 251, 0.9);
      padding: 8px 12px;
      border-radius: 12px;
      border: 1px solid rgba(209, 213, 219, 0.9);
      backdrop-filter: blur(8px);
    }

    .status {
      font-size: 14px;
      line-height: 1.4;
    }

    #currentPlayer {
      font-weight: 700;
    }

    .config {
      font-size: 12px;
      display: flex;
      align-items: center;
      gap: 6px;
      flex-wrap: wrap;
      background: rgba(249, 250, 251, 0.9);
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(209, 213, 219, 0.9);
    }

    .config select,
    .config input[type="number"],
    .config input[type="text"] {
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid #d4d4d8;
      font-size: 12px;
      background: #f9fafb;
      width: 70px;
    }

    /* í…ìŠ¤íŠ¸ ì…ë ¥ì°½ ë„ˆë¹„ë¥¼ ëŠ˜ë ¤ì„œ ì˜ˆì‹œ ë¬¸êµ¬ê°€ ì˜ ë³´ì´ê²Œ ì¡°ì • */
    .config input[type="text"] {
      width: 160px; 
    }

    .config label {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .config button {
      padding: 4px 10px;
      border-radius: 999px;
      border: 1px solid #d4d4d8;
      background: #f3f4f6;
      cursor: pointer;
      font-size: 12px;
    }

    .config button:active {
      transform: translateY(1px);
    }

    /* ë§µ ì—ë””í„° íˆ´ë°” ìŠ¤íƒ€ì¼ */
    .editor-toolbar {
      width: 100%;
      margin-top: 8px;
      padding: 8px;
      background: #f1f5f9;
      border-radius: 12px;
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
      border: 1px dashed #cbd5e1;
    }
    .editor-label {
      font-size: 13px;
      font-weight: 700;
      color: #334155;
      margin-right: 4px;
    }
    .tool-radio {
      display: none; /* ì‹¤ì œ ë¼ë””ì˜¤ ë²„íŠ¼ ìˆ¨ê¹€ */
    }
    .tool-btn {
      padding: 4px 12px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 600;
      cursor: pointer;
      background: #fff;
      border: 1px solid #cbd5e1;
      display: flex;
      align-items: center;
      gap: 4px;
      transition: all 0.2s;
    }
    .tool-btn:hover {
      background: #f8fafc;
    }
    /* ì„ íƒëœ ë„êµ¬ ìŠ¤íƒ€ì¼ */
    .tool-radio:checked + .tool-btn {
      background: #3b82f6;
      color: white;
      border-color: #2563eb;
      box-shadow: 0 2px 5px rgba(59, 130, 246, 0.3);
    }
    /* ë„êµ¬ë³„ ë¯¸ì„¸ ìƒ‰ìƒ ì¡°ì • (ì„ íƒ ì‹œ) */
    #tool-x2:checked + .tool-btn { background: #ef4444; border-color: #dc2626; }
    #tool-half:checked + .tool-btn { background: #3b82f6; border-color: #2563eb; }
    #tool-trap:checked + .tool-btn { background: #f59e0b; border-color: #d97706; }
    #tool-gold:checked + .tool-btn { background: #a855f7; border-color: #9333ea; }

    .dice-box {
      display: flex;
      flex-direction: column;
      gap: 6px;
      align-items: flex-end;
      position: relative;
      padding: 6px 10px;
      border-radius: 16px;
    }

    .dice-box::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      background:
        radial-gradient(circle at 10% 0%, rgba(59, 130, 246, 0.18), transparent 55%),
        radial-gradient(circle at 90% 100%, rgba(244, 114, 182, 0.18), transparent 55%);
      z-index: -1;
    }

    .dice-row {
      display: flex;
      align-items: center;
      gap: 8px;
      flex-wrap: wrap;
    }

    #rollBtn,
    #skipBtn {
      padding: 8px 14px;
      border-radius: 999px;
      border: none;
      cursor: pointer;
      font-size: 14px;
      font-weight: 600;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.12);
      color: #fff;
      transition: transform 0.05s ease, box-shadow 0.05s ease, opacity 0.2s ease;
    }

    #rollBtn {
      background: linear-gradient(135deg, #4f46e5, #6366f1);
    }

    #skipBtn {
      background: linear-gradient(135deg, #6b7280, #9ca3af);
    }

    #rollBtn:active,
    #skipBtn:active {
      transform: translateY(1px);
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.18);
    }

    #rollBtn:disabled,
    #skipBtn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
      box-shadow: none;
      transform: none;
    }

    .dice-visual {
      width: 48px;
      height: 48px;
      border-radius: 12px;
      border: 2px solid #e5e7eb;
      background: #ffffff;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 26px;
      font-weight: 700;
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.06);
      transition: background 0.2s ease, border-color 0.2s ease, color 0.2s ease, box-shadow 0.2s ease;
    }

    /* ğŸ² êµ´ë¦¬ëŠ” ì¤‘ì¼ ë•Œ â€“ íšŒì „ */
    .dice-visual.rolling {
      animation: dice-spin 0.9s ease-out;
    }

    @keyframes dice-spin {
      0% {
        transform: translateY(0px) scale(1.0) rotateZ(0deg);
      }
      30% {
        transform: translateY(-4px) scale(1.25) rotateZ(360deg);
      }
      70% {
        transform: translateY(-2px) scale(1.1) rotateZ(720deg);
      }
      100% {
        transform: translateY(0px) scale(1.0) rotateZ(1080deg);
      }
    }

    /* ì¹˜íŠ¸ ìƒíƒœì¼ ë•ŒëŠ” íšŒì „ ì• ë‹ˆë©”ì´ì…˜ë§Œ ì ìš© (ì¤‘ë³µ ë°©ì§€) */
    .dice-visual.rolling.cheat-active {
      animation: dice-spin 0.9s ease-out;
    }

    .dice-pip-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      width: 100%;
      height: 100%;
      gap: 2px;
    }

    .dice-cell {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .dice-pip {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      background: currentColor;
    }

    .dice-value {
      font-size: 12px;
      max-width: 260px;
      text-align: right;
    }

    .cheat-badge {
      margin-left: 8px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid #e5e7eb;
      background: #f9fafb;
      font-size: 13px;
      font-weight: 700;
      white-space: nowrap;
    }

    .cheat-badge span {
      font-weight: 600;
      color: #4b5563;
    }

    .board {
      display: grid;
      grid-template-columns: repeat(10, 1fr);
      gap: 4px;
      margin-top: 8px;
    }

    .cell {
      position: relative;
      border-radius: 10px;
      border: 1px solid #e0e0e0;
      background: #fafafa;
      min-height: 60px;
      padding: 4px;
      box-sizing: border-box;
      font-size: 11px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      transition: box-shadow 0.2s ease, transform 0.2s ease;
      cursor: pointer;
      user-select: none; /* í´ë¦­ ì‹œ í…ìŠ¤íŠ¸ ì„ íƒ ë°©ì§€ */
    }

    /* ===== íŠ¹ìˆ˜ ì¹¸ ì•„ì´ì½˜ + ë°˜ì§ íš¨ê³¼ ===== */
    .cell.zone-boost::after,
    .cell.zone-slow::after,
    .cell.zone-reset::after,
    .cell.zone-gkey::after {
      position: absolute;
      right: 6px;
      top: 4px;
      font-size: 14px;
      opacity: 0.9;
    }

    /* ì•„ì´ì½˜ ëª¨ì–‘ */
    .cell.zone-boost::after { content: "âš¡"; }   /* x2 ì¹¸ */
    .cell.zone-slow::after  { content: "ğŸ¢"; }   /* 1/2 ì¹¸ */
    .cell.zone-reset::after { content: "â˜ "; }   /* í•¨ì • ì¹¸ */
    .cell.zone-gkey::after  { content: "ğŸ”‘"; }   /* í™©ê¸ˆì—´ì‡  ì¹¸ */

    /* ì€ì€í•œ ë„¤ì˜¨ í…Œë‘ë¦¬ */
    .cell.zone-boost {
      box-shadow: 0 0 10px rgba(239, 68, 68, 0.35);
    }
    .cell.zone-slow {
      box-shadow: 0 0 10px rgba(59, 130, 246, 0.35);
    }
    .cell.zone-reset {
      box-shadow: 0 0 10px rgba(234, 179, 8, 0.45);
    }
    .cell.zone-gkey {
      box-shadow: 0 0 12px rgba(168, 85, 247, 0.6);
    }

    .cell:hover {
      transform: translateY(-2px);
      box-shadow: 0 8px 18px rgba(15, 23, 42, 0.14);
      z-index: 10;
    }
    
    /* ì—ë””í„° ëª¨ë“œì¼ ë•Œ ë§ˆìš°ìŠ¤ ì»¤ì„œ ë³€ê²½ */
    .game-container.editor-mode-x2 .cell { cursor: cell; }
    .game-container.editor-mode-half .cell { cursor: cell; }
    .game-container.editor-mode-trap .cell { cursor: not-allowed; }
    .game-container.editor-mode-gold .cell { cursor: alias; }

    .cell-index {
      font-weight: 600;
      opacity: 0.7;
    }

    .cell-zone-label {
      font-size: 10px;
      opacity: 0.9;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .cell-zone-label::before {
      content: "";
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: #9ca3af;
    }

    .token-container {
      position: relative;
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      margin-top: 4px;
    }

    .token {
      width: 16px;
      height: 16px;
      border-radius: 999px;
      border: 2px solid rgba(255, 255, 255, 0.8);
      box-sizing: border-box;
      transition: transform 0.1s ease;
    }

    .zone-boost {
      background: #ffeaea;
      border-color: #ffb3b3;
    }
    .zone-boost .cell-zone-label::before {
      background: #ef4444;
    }

    .zone-slow {
      background: #e8f0ff;
      border-color: #b3c6ff;
    }
    .zone-slow .cell-zone-label::before {
      background: #3b82f6;
    }

    .zone-reset {
      background: #fef3c7;
      border-color: #facc15;
    }
    .zone-reset .cell-zone-label::before {
      background: #facc15;
    }

    .zone-gkey {
      background: #f5f3ff;
      border-color: #a855f7;
    }
    .zone-gkey .cell-zone-label::before {
      background: #a855f7;
    }

    .cell.start-cell {
      border: 2px solid #22c55e;
      box-shadow: 0 0 10px rgba(34, 197, 94, 0.5);
      background: #ecfdf5;
    }

    .cell.finish-cell {
      border: 2px solid #f97316;
      box-shadow: 0 0 12px rgba(249, 115, 22, 0.7);
      background: #fff7ed;
    }

    .legend {
      margin-top: 10px;
      font-size: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    .legend-color {
      width: 14px;
      height: 14px;
      border-radius: 4px;
      border: 1px solid #ccc;
    }

    .legend-color.boost {
      background: #ffeaea;
      border-color: #ffb3b3;
    }

    .legend-color.slow {
      background: #e8f0ff;
      border-color: #b3c6ff;
    }

    .legend-color.reset {
      background: #fef3c7;
      border-color: #facc15;
    }

    .legend-color.gkey {
      background: #f5f3ff;
      border-color: #a855f7;
    }

    .players-legend {
      font-size: 12px;
      margin-top: 6px;
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    .player-pill {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 8px;
      border-radius: 999px;
      background: #f3f4f6;
      border: 1px solid transparent;
      transition: border 0.1s ease, background 0.1s ease;
    }

    .player-dot {
      width: 10px;
      height: 10px;
      border-radius: 999px;
    }

    .player-pill.current-turn {
      border: 2px solid #111827;
      background: #e0f2fe;
    }

    .token.current-turn {
      transform: scale(1.2);
      animation: pulse 0.8s ease-in-out infinite;
    }

    @keyframes pulse {
      0%   { transform: scale(1.0); }
      50%  { transform: scale(1.3); }
      100% { transform: scale(1.0); }
    }

    .log-box {
      margin-top: 14px;
      font-size: 12px;
      max-height: 200px;
      overflow-y: auto;
      background: #f9fafb;
      border-radius: 10px;
      padding: 8px;
      border: 1px solid #e5e7eb;
    }

    .log-entry {
      margin-bottom: 4px;
    }

    /* ê³µí†µ ì˜¤ë²„ë ˆì´ (í™©ê¸ˆì—´ì‡ /ì¹˜íŠ¸) */
    #goldenKeyOverlay {
      position: fixed;
      inset: 0;
      display: none;
      align-items: center;
      justify-content: center;
      background: rgba(15, 23, 42, 0.55);
      z-index: 9998;
      pointer-events: none;
      opacity: 0;
    }

    #goldenKeyOverlay.show {
      display: flex;
      animation-name: overlayFade;
      animation-timing-function: ease-out;
      animation-fill-mode: forwards;
    }

    @keyframes overlayFade {
      0%   { opacity: 0; }
      20%  { opacity: 1; }
      80%  { opacity: 1; }
      100% { opacity: 0; }
    }

    #goldenKeyPopup,
    #cheatPopup {
      padding: 16px 26px;
      border-radius: 999px;
      font-size: 24px;
      font-weight: 800;
      display: none;
      align-items: center;
      gap: 10px;
      box-shadow: 0 14px 40px rgba(0, 0, 0, 0.35);
      z-index: 9999;
      transform: scale(0.4);
      opacity: 0;
    }

    #goldenKeyPopup {
      position: relative;
      background: rgba(250, 204, 21, 0.97);
      color: #78350f;
      font-size: 28px;
    }

    #cheatPopup {
      position: relative;
      background: rgba(249, 250, 251, 0.95);
      color: #111827;
    }

    #goldenKeyPopup.show,
    #cheatPopup.show {
      display: flex;
      animation-name: gkey-pop;
      animation-timing-function: ease-out;
      animation-fill-mode: forwards;
    }

    @keyframes gkey-pop {
      0% {
        opacity: 0;
        transform: scale(0.2);
      }
      30% {
        opacity: 1;
        transform: scale(1.05);
      }
      70% {
        opacity: 1;
        transform: scale(1);
      }
      100% {
        opacity: 0;
        transform: scale(1.1);
      }
    }

    .sparkle {
      position: absolute;
      width: 10px;
      height: 10px;
      border-radius: 999px;
      background: radial-gradient(circle, #fefce8 0%, #facc15 40%, transparent 70%);
      opacity: 0;
      box-shadow: 0 0 14px rgba(250, 250, 170, 0.9);
      pointer-events: none;
      animation-name: sparkleBlink;
      animation-timing-function: ease-out;
      animation-fill-mode: forwards;
    }

    @keyframes sparkleBlink {
      0%   { transform: scale(0.2); opacity: 0; }
      30%  { transform: scale(1.3); opacity: 1; }
      70%  { transform: scale(0.9); opacity: 0.9; }
      100% { transform: scale(0.4); opacity: 0; }
    }

    .token.token-fast {
      box-shadow: 0 0 10px rgba(56, 189, 248, 0.8);
      animation: fastMove 0.2s linear infinite;
    }

    @keyframes fastMove {
      0%   { transform: scale(1.15) translateX(-1px); }
      50%  { transform: scale(1.25) translateX(1px); }
      100% { transform: scale(1.15) translateX(-1px); }
    }

    .cell.landing {
      animation: landingFlash 0.35s ease-out;
    }

    @keyframes landingFlash {
      0% {
        transform: scale(1);
        box-shadow: 0 0 0 rgba(250, 204, 21, 0);
      }
      50% {
        transform: scale(1.03);
        box-shadow: 0 0 12px rgba(250, 204, 21, 0.9);
      }
      100% {
        transform: scale(1);
        box-shadow: 0 0 0 rgba(250, 204, 21, 0);
      }
    }

    .game-container.shake {
      animation: shakeBoard 0.4s ease;
    }

    @keyframes shakeBoard {
      0%   { transform: translateX(0); }
      20%  { transform: translateX(-4px); }
      40%  { transform: translateX(4px); }
      60%  { transform: translateX(-3px); }
      80%  { transform: translateX(3px); }
      100% { transform: translateX(0); }
    }

    @media (max-width: 600px) {
      .cell {
        min-height: 48px;
      }
      .board {
        grid-template-columns: repeat(6, 1fr);
      }
      .dice-value {
        max-width: 200px;
      }
      .dice-row {
        flex-wrap: wrap;
      }
      #goldenKeyPopup {
        font-size: 22px;
        padding: 12px 18px;
      }
      #cheatPopup {
        font-size: 20px;
        padding: 10px 16px;
      }
    }

    /* ===================== */
    /* í…Œë§ˆë³„ ìƒ‰ìƒ ìŠ¤í‚¨    */
    /* ===================== */

    body.theme-default {
    }

    body.theme-space {
      background: radial-gradient(circle at top, #1e293b 0, #020617 45%, #000000 100%);
      color: #e5e7eb;
    }
    body.theme-space .game-container {
      background: rgba(15, 23, 42, 0.96);
      border-radius: 18px;
      box-shadow: 0 20px 50px rgba(0, 0, 0, 0.6);
    }
    body.theme-space .cell {
      background: #020617;
      border-color: #1f2937;
    }
    body.theme-space .zone-boost {
      background: rgba(8, 47, 73, 0.9);
      border-color: #38bdf8;
    }
    body.theme-space .zone-slow {
      background: rgba(30, 64, 175, 0.9);
      border-color: #a5b4fc;
    }
    body.theme-space .zone-reset {
      background: rgba(127, 29, 29, 0.9);
      border-color: #f97373;
    }
    body.theme-space .zone-gkey {
      background: rgba(88, 28, 135, 0.95);
      border-color: #fbbf24;
    }
    body.theme-space .log-box {
      background: rgba(15, 23, 42, 0.9);
      border-color: #1f2937;
    }
    body.theme-space .players-legend .player-pill {
      background: rgba(15, 23, 42, 0.9);
    }
    body.theme-space .editor-toolbar {
        background: #0f172a;
        border-color: #1e293b;
    }
    body.theme-space .editor-label { color: #cbd5e1; }
    body.theme-space .tool-btn {
        background: #1e293b;
        color: #fff;
        border-color: #334155;
    }
    body.theme-space .tool-btn:hover { background: #334155; }


    body.theme-forest {
      background: linear-gradient(135deg, #064e3b, #047857);
    }
    body.theme-forest .game-container {
      background: #ecfdf5;
    }
    body.theme-forest .cell {
      background: #d1fae5;
      border-color: #6ee7b7;
    }
    body.theme-forest .zone-boost {
      background: #bbf7d0;
      border-color: #22c55e;
    }
    body.theme-forest .zone-slow {
      background: #a7f3d0;
      border-color: #22c55e;
    }
    body.theme-forest .zone-reset {
      background: #fef3c7;
      border-color: #f97316;
    }
    body.theme-forest .zone-gkey {
      background: #f5f3ff;
      border-color: #4c1d95;
    }
    body.theme-forest .log-box {
      background: #f0fdf4;
      border-color: #bbf7d0;
    }
    body.theme-forest .players-legend .player-pill {
      background: #dcfce7;
    }

    body.theme-desert {
      background: linear-gradient(135deg, #f97316, #facc15);
    }
    body.theme-desert .game-container {
      background: #fffbeb;
    }
    body.theme-desert .cell {
      background: #fef3c7;
      border-color: #fbbf24;
    }
    body.theme-desert .zone-boost {
      background: #fed7aa;
      border-color: #f97316;
    }
    body.theme-desert .zone-slow {
      background: #fee2e2;
      border-color: #f87171;
    }
    body.theme-desert .zone-reset {
      background: #fee2e2;
      border-color: #b91c1c;
    }
    body.theme-desert .zone-gkey {
      background: #fef9c3;
      border-color: #a16207;
    }
    body.theme-desert .log-box {
      background: #fffbeb;
      border-color: #facc15;
    }
    body.theme-desert .players-legend .player-pill {
      background: #fffbeb;
    }

    body.theme-neon {
      background: radial-gradient(circle at top, #111827 0, #020617 50%, #000000 100%);
      color: #e5e7eb;
    }
    body.theme-neon .game-container {
      background: rgba(15, 23, 42, 0.98);
      border-radius: 18px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.75);
    }
    body.theme-neon .cell {
      background: #020617;
      border-color: #4c1d95;
      box-shadow: 0 0 0 1px rgba(139, 92, 246, 0.3);
    }
    body.theme-neon .zone-boost {
      background: rgba(8, 47, 73, 0.9);
      border-color: #22d3ee;
      box-shadow: 0 0 15px rgba(56, 189, 248, 0.7);
    }
    body.theme-neon .zone-slow {
      background: rgba(76, 29, 149, 0.9);
      border-color: #a855f7;
      box-shadow: 0 0 15px rgba(168, 85, 247, 0.7);
    }
    body.theme-neon .zone-reset {
      background: rgba(127, 29, 29, 0.95);
      border-color: #fb7185;
      box-shadow: 0 0 15px rgba(248, 113, 113, 0.7);
    }
    body.theme-neon .zone-gkey {
      background: rgba(250, 204, 21, 0.95);
      border-color: #f97316;
      box-shadow: 0 0 18px rgba(250, 204, 21, 0.8);
    }
    body.theme-neon .log-box {
      background: rgba(15, 23, 42, 0.95);
      border-color: #4c1d95;
    }
    body.theme-neon .players-legend .player-pill {
      background: rgba(30, 64, 175, 0.7);
    }
    body.theme-neon .editor-toolbar {
        background: rgba(15, 23, 42, 0.95);
        border-color: #4c1d95;
    }
    body.theme-neon .editor-label { color: #a5b4fc; }
    body.theme-neon .tool-btn {
        background: #0f172a;
        color: #e5e7eb;
        border-color: #4c1d95;
    }
    body.theme-neon .tool-btn:hover { background: #1e293b; }


    h1 {
      text-align: center;
      margin-bottom: 6px;
      font-size: 28px;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      background: linear-gradient(120deg, #4f46e5, #ec4899, #f97316);
      -webkit-background-clip: text;
      color: transparent;
      filter: drop-shadow(0 2px 6px rgba(15, 23, 42, 0.25));
    }

    .game-container::before {
      content: "";
      position: absolute;
      inset: -2px;
      border-radius: inherit;
      background: linear-gradient(
        135deg,
        rgba(79, 70, 229, 0.55),
        rgba(14, 165, 233, 0.45),
        rgba(236, 72, 153, 0.55)
      );
      opacity: 0.7;
      z-index: -1;
    }
  </style>
</head>
<body class="theme-default">
  <h1>ì£¼ì‚¬ìœ„ ë³´ë“œê²Œì„</h1>
  <p style="text-align:center; font-size:12px; opacity:0.7; margin-top:-4px; margin-bottom:10px;">
    ë§Œë“  ì´: ì„œë¯¼ì¬
  </p>

  <div class="game-container" id="gameContainer">
    <div class="top-panel">
      <div class="status-block">
        <div class="status">
          í˜„ì¬ ì°¨ë¡€: <span id="currentPlayer"></span><br />
          ë§ ìœ„ì¹˜: <span id="positions"></span>
        </div>
        <div class="config">
          <label>
            ì¸ì› ìˆ˜:
            <select id="playerCount">
              <option value="1">1ëª…</option>
              <option value="2" selected>2ëª…</option>
              <option value="3">3ëª…</option>
              <option value="4">4ëª…</option>
              <option value="5">5ëª…</option>
              <option value="6">6ëª…</option>
            </select>
          </label>
          <label>
            í…Œë§ˆ:
            <select id="themeSelect">
              <option value="default">ê¸°ë³¸</option>
              <option value="space">ìš°ì£¼</option>
              <option value="forest">ìˆ²</option>
              <option value="desert">ì‚¬ë§‰</option>
              <option value="neon">ë„¤ì˜¨</option>
            </select>
          </label>
          <label>
            ì „ì²´ ì¹¸ìˆ˜:
            <input type="number" id="boardSizeInput" min="6" max="200" value="30" />
          </label>
          <label>
            x2 ì¹¸:
            <input type="text" id="x2CellsInput" placeholder="ì˜ˆ: 2,5,9 ë˜ëŠ” 2~5" />
          </label>
          <label>
            1/2 ì¹¸:
            <input type="text" id="halfCellsInput" placeholder="ì˜ˆ: 4,6 ë˜ëŠ” 10~12" />
          </label>
          <label>
            í•¨ì • ì¹¸(ì¶œë°œë¡œ):
            <input type="text" id="resetCellsInput" placeholder="ì˜ˆ: 1,3 ë˜ëŠ” 20~22" />
          </label>
          <label>
            í™©ê¸ˆì—´ì‡  ì¹¸:
            <input type="text" id="gKeyCellsInput" placeholder="ì˜ˆ: 7,8 ë˜ëŠ” 15~18" />
          </label>
          <label>
            ì»¤ë§¨ë“œ:
            <input type="text" id="secretCodeInput" placeholder="ì¹˜íŠ¸ ì½”ë“œ" />
          </label>
          <button id="startBtn">ê²Œì„ ì‹œì‘ / ë¦¬ì…‹</button>
        </div>
        
        <div class="editor-toolbar">
            <span class="editor-label">ğŸ› ï¸ ë§µ ì—ë””í„°:</span>
            
            <label>
                <input type="radio" name="editorTool" value="none" class="tool-radio" checked id="tool-none">
                <div class="tool-btn">ğŸ‘† ì„ íƒ/ì´ë™(ì¼ë°˜)</div>
            </label>
            <label>
                <input type="radio" name="editorTool" value="x2" class="tool-radio" id="tool-x2">
                <div class="tool-btn">âš¡ x2 ë°°ì†</div>
            </label>
            <label>
                <input type="radio" name="editorTool" value="half" class="tool-radio" id="tool-half">
                <div class="tool-btn">ğŸ¢ 1/2 ë°°ì†</div>
            </label>
            <label>
                <input type="radio" name="editorTool" value="trap" class="tool-radio" id="tool-trap">
                <div class="tool-btn">â˜  í•¨ì •</div>
            </label>
            <label>
                <input type="radio" name="editorTool" value="gold" class="tool-radio" id="tool-gold">
                <div class="tool-btn">ğŸ”‘ í™©ê¸ˆì—´ì‡ </div>
            </label>
        </div>
        <div style="font-size:11px; opacity:0.7; margin-left:6px; margin-top:2px;">
            * ë„êµ¬ë¥¼ ì„ íƒí•œ ë’¤ ë³´ë“œì˜ ì¹¸ì„ í´ë¦­í•˜ì—¬ í•´ë‹¹ ì¹¸ì„ ë§Œë“¤ê±°ë‚˜ ì§€ìš¸ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
        </div>

      </div>

      <div class="dice-box">
        <div class="dice-row">
          <button id="rollBtn">ğŸ² ì£¼ì‚¬ìœ„ êµ´ë¦¬ê¸°</button>
          <button id="skipBtn">â­ï¸ í„´ ìŠ¤í‚µ</button>
          <div class="dice-visual" id="diceVisual">-</div>
          <div class="cheat-badge">
            <span id="cheatText">ì¹˜íŠ¸: ì—†ìŒ</span>
          </div>
        </div>
        <div class="dice-value" id="diceInfo">
          ê²Œì„ì„ ì‹œì‘í•œ ë’¤ ì£¼ì‚¬ìœ„ë¥¼ êµ´ë ¤ ë³´ì„¸ìš”.
        </div>
      </div>
    </div>

    <div class="board" id="board"></div>

    <div class="legend">
      <div class="legend-item">
        <div class="legend-color boost"></div> x2 ë°°ì† ì¹¸:
        <span id="boostRangeText">ì—†ìŒ</span>
      </div>
      <div class="legend-item">
        <div class="legend-color slow"></div> 1/2 ë°°ì† ì¹¸:
        <span id="slowRangeText">ì—†ìŒ</span>
      </div>
      <div class="legend-item">
        <div class="legend-color reset"></div> ì¶œë°œë¡œ ë˜ëŒì•„ê°€ëŠ” ì¹¸:
        <span id="resetRangeText">ì—†ìŒ</span>
      </div>
      <div class="legend-item">
        <div class="legend-color gkey"></div> í™©ê¸ˆì—´ì‡  ì¹¸:
        <span id="gKeyRangeText">ì—†ìŒ</span>
      </div>
      <div class="legend-item">
        âš‘ 0ì¹¸: ì¶œë°œ, ë§ˆì§€ë§‰ ì¹¸: ë„ì°©
      </div>
    </div>

    <div class="players-legend" id="playersLegend"></div>

    <div class="log-box" id="log"></div>
  </div>

  <div id="goldenKeyOverlay">
    <div id="goldenKeyPopup">
      <span>ğŸ”‘</span>
      <span>í™©ê¸ˆì—´ì‡ !</span>
    </div>
    <div id="cheatPopup">
      <span id="cheatPopupIcon">âœ¨</span>
      <span id="cheatPopupText">ì¹˜íŠ¸ ë°œë™!</span>
    </div>
  </div>

  <audio id="seClick"  src="game/click.mp3"  preload="auto"></audio>
  <audio id="seDice"   src="game/dice.mp3"   preload="auto"></audio>
  <audio id="seTrap"   src="game/trap.mp3"   preload="auto"></audio>
  <audio id="seGolden" src="game/golden.mp3" preload="auto"></audio>
  <audio id="seCheat"  src="game/cheat.mp3"  preload="auto"></audio>
  <audio id="seWin"    src="game/win.mp3"    preload="auto"></audio>
  <audio id="seShield" src="game/shield.mp3" preload="auto"></audio>
  <audio id="seSpeed"  src="game/speed.mp3"  preload="auto"></audio>
  <audio id="seSpeedHalf" src="game/speed_half.mp3" preload="auto"></audio>

  <script>
    let BOARD_SIZE = 30;
    
    // íŠ¹ìˆ˜ ì¹¸ ë°ì´í„°ë¥¼ ì „ì—­ ê´€ë¦¬í•˜ì—¬ ì‹¤ì‹œê°„ ì—…ë°ì´íŠ¸ ê°€ëŠ¥í•˜ê²Œ í•¨
    let currentX2List = [];
    let currentHalfList = [];
    let currentResetList = [];
    let currentGoldList = [];
    let specialZones = []; // ê²Œì„ ë¡œì§ì—ì„œ ì“°ëŠ” í†µí•© ë°ì´í„°

    const PLAYER_COLORS = [
      "#ef4444",
      "#3b82f6",
      "#22c55e",
      "#f97316",
      "#a855f7",
      "#eab308"
    ];

    const CHEAT_DEFS = [
      { code: "3025", name: "í™©ê¸ˆ 15", desc: "ì£¼ì‚¬ìœ„ ëˆˆì„ 15ë¡œ ê³ ì •" },
      { code: "1357", name: "ì´ë™ 2ë°°", desc: "ì´ë™ ê±°ë¦¬ 2ë°°" },
      { code: "2468", name: "í•¨ì • ì˜êµ¬ ë¬´ì‹œ", desc: "ë‚¨ì€ ê²Œì„ ë™ì•ˆ í•¨ì • ì¹¸ ë¬´ì‹œ" },
      { code: "4444", name: "2íšŒ ë³´í˜¸ë§‰", desc: "í•´ë¡œìš´ íš¨ê³¼ 2ë²ˆ ë°©ì–´" },
      { code: "9999", name: "ì¶”ê°€ í„´", desc: "ì´ë™ í›„ í•œ ë²ˆ ë” í„´" },
      { code: "1111", name: "ì„ ë‘ ë°”ë¡œ ë’¤ ì›Œí”„", desc: "ì„ ë‘ ë°”ë¡œ ë’¤ ì¹¸ìœ¼ë¡œ ì´ë™" },
      { code: "2222", name: "ì„ ë‘ì™€ êµí™˜", desc: "ì„ ë‘ì™€ ìœ„ì¹˜ ë°”ê¾¸ê¸°" },
      { code: "3333", name: "ë‹¤ë¥¸ ì‚¬ëŒ -1ì¹¸", desc: "ë‚˜ ë¹¼ê³  ëª¨ë‘ 1ì¹¸ ë’¤ë¡œ" },
      { code: "5555", name: "ì¬êµ´ë¦¼(í° ìˆ˜)", desc: "ë‘ ë²ˆ êµ´ë ¤ ë” í° ìˆ˜ ì‚¬ìš©" },
      { code: "6666", name: "ì„ ë‘ ì›Œí”„+í„´ ìŠ¤í‚µ", desc: "ì„ ë‘ ìœ„ì¹˜ë¡œ ì´ë™, ë‹¤ìŒ ìê¸° í„´ ìŠ¤í‚µ" },
      { code: "7777", name: "Â±3 ëœë¤", desc: "+3 ë˜ëŠ” -3 ëœë¤ ì´ë™" },
      { code: "8888", name: "ì¤‘ì•™ ì›Œí”„", desc: "ë³´ë“œ ì¤‘ì•™ìœ¼ë¡œ ì´ë™" }
    ];

    let players = [];
    let currentPlayerIndex = 0;
    let gameOver = false;
    let isAnimating = false;
    let isRollingDice = false;

    const cellTokenEls = [];

    const boardEl = document.getElementById("board");
    const gameContainerEl = document.getElementById("gameContainer");
    const rollBtn = document.getElementById("rollBtn");
    const skipBtn = document.getElementById("skipBtn");
    const diceInfoEl = document.getElementById("diceInfo");
    const diceVisualEl = document.getElementById("diceVisual");
    const currentPlayerEl = document.getElementById("currentPlayer");
    const positionsEl = document.getElementById("positions");
    const logEl = document.getElementById("log");
    const playersLegendEl = document.getElementById("playersLegend");
    const playerCountSelect = document.getElementById("playerCount");
    const startBtn = document.getElementById("startBtn");
    const boardSizeInput = document.getElementById("boardSizeInput");
    
    // Inputs
    const x2CellsInput = document.getElementById("x2CellsInput");
    const halfCellsInput = document.getElementById("halfCellsInput");
    const resetCellsInput = document.getElementById("resetCellsInput");
    const gKeyCellsInput = document.getElementById("gKeyCellsInput");
    
    const secretCodeInput = document.getElementById("secretCodeInput");
    const boostRangeText = document.getElementById("boostRangeText");
    const slowRangeText = document.getElementById("slowRangeText");
    const resetRangeText = document.getElementById("resetRangeText");
    const gKeyRangeText = document.getElementById("gKeyRangeText");
    const cheatTextEl = document.getElementById("cheatText");
    const goldenKeyOverlayEl = document.getElementById("goldenKeyOverlay");
    const goldenKeyPopupEl = document.getElementById("goldenKeyPopup");
    const cheatPopupEl = document.getElementById("cheatPopup");
    const cheatPopupTextEl = document.getElementById("cheatPopupText");
    const cheatPopupIconEl = document.getElementById("cheatPopupIcon");
    const themeSelect = document.getElementById("themeSelect");

    // Editor Tools
    const toolRadios = document.getElementsByName("editorTool");

    const THEME_CLASS_LIST = [
      "theme-default",
      "theme-space",
      "theme-forest",
      "theme-desert",
      "theme-neon"
    ];

    function applyTheme(themeName) {
      const body = document.body;
      THEME_CLASS_LIST.forEach((cls) => body.classList.remove(cls));
      body.classList.add("theme-" + themeName);
    }

    // ğŸµ íš¨ê³¼ìŒ ë§¤í•‘
    const soundMap = {
      click:  document.getElementById("seClick"),
      dice:   document.getElementById("seDice"),
      trap:   document.getElementById("seTrap"),
      golden: document.getElementById("seGolden"),
      cheat:  document.getElementById("seCheat"),
      win:    document.getElementById("seWin"),
      shield: document.getElementById("seShield"),
      speed:  document.getElementById("seSpeed"),
      speedHalf: document.getElementById("seSpeedHalf")
    };

    function playSound(name) {
      const audio = soundMap[name];
      if (!audio) return;
      try {
        audio.currentTime = 0;
        audio.play();
      } catch (e) {}
    }

    let popupTimerId = null;

    // â­ HEX â†’ rgba ë³€í™˜ (ë„¤ì˜¨ ê·¸ë¼ë°ì´ì…˜ìš©)
    function hexToRgba(hex, alpha) {
      if (!hex) return "";
      let h = hex.trim();
      if (h[0] === "#") h = h.slice(1);
      if (h.length === 3) {
        h = h[0] + h[0] + h[1] + h[1] + h[2] + h[2];
      }
      if (h.length !== 6) return hex;
      const r = parseInt(h.slice(0, 2), 16);
      const g = parseInt(h.slice(2, 4), 16);
      const b = parseInt(h.slice(4, 6), 16);
      if ([r, g, b].some(v => Number.isNaN(v))) return hex;
      return `rgba(${r}, ${g}, ${b}, ${alpha})`;
    }

    function setDiceFace(value) {
      diceVisualEl.innerHTML = "";

      if (value >= 1 && value <= 6) {
        const pipMap = {
          1: [4],
          2: [0, 8],
          3: [0, 4, 8],
          4: [0, 2, 6, 8],
          5: [0, 2, 4, 6, 8],
          6: [0, 2, 3, 5, 6, 8]
        };
        const positions = pipMap[value] || [];

        const grid = document.createElement("div");
        grid.className = "dice-pip-grid";

        for (let i = 0; i < 9; i++) {
          const cell = document.createElement("div");
          cell.className = "dice-cell";
          if (positions.includes(i)) {
            const pip = document.createElement("div");
            pip.className = "dice-pip";
            cell.appendChild(pip);
          }
          grid.appendChild(cell);
        }

        diceVisualEl.appendChild(grid);
      } else {
        diceVisualEl.textContent = String(value);
      }
    }

    function log(message) {
      const div = document.createElement("div");
      div.className = "log-entry";
      div.textContent = message;
      logEl.prepend(div);
    }

    // êµ¬ì—­ ì°¾ê¸° (í˜„ì¬ ì—…ë°ì´íŠ¸ëœ ë¦¬ìŠ¤íŠ¸ ê¸°ë°˜)
    function findZone(pos) {
      // specialZonesë¥¼ ë§¤ë²ˆ ë‹¤ì‹œ ë¹Œë“œí•˜ê±°ë‚˜, global ë³€ìˆ˜ë¥¼ ì°¸ì¡°
      return specialZones.find((z) => pos >= z.start && pos <= z.end) || null;
    }

    function getMultiplierInfo(pos) {
      const zone = findZone(pos);
      if (!zone) return { multiplier: 1, label: "ì¼ë°˜ êµ¬ê°„" };
      return {
        multiplier: zone.multiplier,
        label:
          zone.multiplier > 1
            ? `${zone.multiplier}ë°° ì†ë„ êµ¬ê°„`
            : `${zone.multiplier}ë°° ëŠë ¤ì§€ëŠ” êµ¬ê°„`
      };
    }

    function resetDiceStyle() {
      diceVisualEl.classList.remove("cheat-active");
      diceVisualEl.style.borderColor = "";
      diceVisualEl.style.background = "";
      diceVisualEl.style.color = "";
      diceVisualEl.style.boxShadow = "";
    }

    function setDiceNeonForColor(color) {
      if (!color) {
        resetDiceStyle();
        return;
      }
      const softOuter = hexToRgba(color, 0.25);
      const softInner = hexToRgba(color, 0.10);

      diceVisualEl.style.borderColor = softOuter;
      diceVisualEl.style.background =
        `radial-gradient(circle at 30% 20%, #ffffff 0%, ${softInner} 50%, ${softOuter} 100%)`;
      diceVisualEl.style.color = "#111827";
      diceVisualEl.style.boxShadow = `0 0 10px ${softOuter}`;
    }

    function parseCellList(raw, boardSize) {
      const result = [];
      if (!raw || raw.trim().length === 0) return result;

      const tokens = raw
        .split(/[,\s]+/)
        .map((t) => t.trim())
        .filter(Boolean);

      tokens.forEach((token) => {
        const rangeMatch = token.match(/^(\d+)\s*~\s*(\d+)$/);
        if (rangeMatch) {
          let a = parseInt(rangeMatch[1], 10);
          let b = parseInt(rangeMatch[2], 10);
          if (isNaN(a) || isNaN(b)) return;
          if (a > b) {
            const tmp = a;
            a = b;
            b = tmp;
          }
          for (let n = a; n <= b; n++) {
            if (n > 0 && n < boardSize - 1) result.push(n);
          }
          return;
        }

        const n = parseInt(token, 10);
        if (!isNaN(n) && n > 0 && n < boardSize - 1) {
          result.push(n);
        }
      });

      return Array.from(new Set(result)).sort((a, b) => a - b);
    }

    function getCheatsForCurrentRoll() {
      const cheats = {
        goldenTen: false,
        doubleStep: false,
        trapImmune: false,
        extraTurn: false,
        leadFollow: false,
        swapLead: false,
        warpLeadSkip: false,
        pushOthersBack: false,
        shield2turn: false,
        rerollHigher: false,
        randomPlusMinus3: false,
        warpMiddle: false,
        triggered: []
      };

      const currentPlayer = players[currentPlayerIndex];

      let rawCodes = [];
      const raw = secretCodeInput.value;
      if (raw && raw.trim().length > 0) {
        rawCodes = raw.split(/[,\s]+/).map(c => c.trim()).filter(Boolean);
      }

      if (currentPlayer && currentPlayer.storedCheatCode) {
        rawCodes.push(currentPlayer.storedCheatCode);
        currentPlayer.storedCheatCode = null;
      }

      if (rawCodes.length === 0) return cheats;

      const codes = Array.from(new Set(rawCodes));
      let hasUnknown = false;

      codes.forEach((code) => {
        const def = CHEAT_DEFS.find(d => d.code === code);
        if (!def) {
          hasUnknown = true;
          return;
        }

        cheats.triggered.push(def);

        if (code === "3025")      cheats.goldenTen = true;
        else if (code === "1357") cheats.doubleStep = true;
        else if (code === "2468") cheats.trapImmune = true;
        else if (code === "9999") cheats.extraTurn = true;
        else if (code === "1111") cheats.leadFollow = true;
        else if (code === "2222") cheats.swapLead = true;
        else if (code === "6666") cheats.warpLeadSkip = true;
        else if (code === "3333") cheats.pushOthersBack = true;
        else if (code === "4444") cheats.shield2turn = true;
        else if (code === "5555") cheats.rerollHigher = true;
        else if (code === "7777") cheats.randomPlusMinus3 = true;
        else if (code === "8888") cheats.warpMiddle = true;
      });

      if (hasUnknown) {
        log("â“ ì•Œ ìˆ˜ ì—†ëŠ” ì½”ë“œê°€ ìˆì–´ ë¬´ì‹œë˜ì—ˆìŠµë‹ˆë‹¤.");
      }

      if (cheats.triggered.length > 0) {
        const txt = cheats.triggered
          .map(d => `${d.code}(${d.name})`)
          .join(", ");
        log(`âœ¨ ì¹˜íŠ¸ ì½”ë“œ: ${txt} ë°œë™`);
      }

      return cheats;
    }

    function spawnSparkles(baseColor) {
      const color = baseColor || "#facc15";
      const oldSparkles = goldenKeyOverlayEl.querySelectorAll(".sparkle");
      oldSparkles.forEach((el) => el.remove());

      const SPARKLE_COUNT = 90;
      for (let i = 0; i < SPARKLE_COUNT; i++) {
        const s = document.createElement("div");
        s.className = "sparkle";

        const topPercent = Math.random() * 100;
        const leftPercent = Math.random() * 100;
        const scale = 0.3 + Math.random() * 2.0;
        const delay = Math.random() * 0.7;
        const duration = 0.8 + Math.random() * 1.0;

        s.style.top = topPercent + "%";
        s.style.left = leftPercent + "%";
        s.style.transform = `scale(${scale})`;
        s.style.animationDelay = `${delay}s`;
        s.style.animationDuration = `${duration}s`;
        s.style.background = `radial-gradient(circle, #fefce8 0%, ${color} 40%, transparent 70%)`;
        s.style.boxShadow = `0 0 14px ${color}cc`;

        goldenKeyOverlayEl.appendChild(s);
      }
    }

    function showCheatPopup(style, labelText, prefixLabel = "ì¹˜íŠ¸", icon = "âœ¨", durationMs = 2000) {
      if (prefixLabel === "ì¹˜íŠ¸")         playSound("cheat");
      else if (prefixLabel === "í•¨ì •")    playSound("trap");
      else if (prefixLabel === "ë°©ì–´")    playSound("shield");
      else if (prefixLabel === "x2 ë°°ì†") playSound("speed");
      else if (prefixLabel === "1/2 ë°°ì†") playSound("speedHalf");

      goldenKeyOverlayEl.classList.remove("show");
      goldenKeyPopupEl.classList.remove("show");
      cheatPopupEl.classList.remove("show");

      if (popupTimerId !== null) {
        clearTimeout(popupTimerId);
        popupTimerId = null;
      }

      const color = style && style.color ? style.color : "#f97316";
      const bg = style && style.bg ? style.bg : "#fff7ed";

      cheatPopupEl.style.background = bg;
      cheatPopupEl.style.color = color;

      const popupSeconds = durationMs / 1000;
      cheatPopupEl.style.animationDuration = popupSeconds + "s";
      goldenKeyOverlayEl.style.animationDuration = popupSeconds + "s";

      cheatPopupIconEl.textContent = icon;

      if (labelText && labelText.length > 0) {
        if (prefixLabel) {
          cheatPopupTextEl.textContent = `${prefixLabel}: ${labelText}`;
        } else {
          cheatPopupTextEl.textContent = labelText;
        }
      } else {
        cheatPopupTextEl.textContent = prefixLabel ? `${prefixLabel}: íš¨ê³¼ ë°œë™!` : "íš¨ê³¼ ë°œë™!";
      }

      void goldenKeyOverlayEl.offsetWidth;

      goldenKeyOverlayEl.classList.add("show");
      spawnSparkles(color);
      cheatPopupEl.classList.add("show");

      popupTimerId = setTimeout(() => {
        goldenKeyOverlayEl.classList.remove("show");
        cheatPopupEl.classList.remove("show");
        const remain = goldenKeyOverlayEl.querySelectorAll(".sparkle");
        remain.forEach((el) => el.remove());
        popupTimerId = null;
      }, durationMs);
    }

    function showCheatText(cheats) {
      let firedText = null;
      if (cheats.triggered && cheats.triggered.length > 0) {
        firedText = cheats.triggered
          .map(d => `${d.name} ë°œë™`)
          .join(" / ");
        cheatTextEl.textContent = "ì¹˜íŠ¸: " + firedText;
      } else {
        cheatTextEl.textContent = "ì¹˜íŠ¸: ì—†ìŒ";
      }

      diceVisualEl.classList.remove("cheat-active");

      const styleMap = {
        goldenTen:       { color: "#f59e0b", bg: "#fffbeb", border: "#fbbf24" },
        doubleStep:      { color: "#3b82f6", bg: "#eff6ff", border: "#bfdbfe" },
        trapImmune:      { color: "#22c55e", bg: "#ecfdf3", border: "#bbf7d0" },
        extraTurn:       { color: "#a855f7", bg: "#faf5ff", border: "#e9d5ff" },
        leadFollow:      { color: "#ec4899", bg: "#fdf2f8", border: "#f9a8d4" },
        swapLead:        { color: "#06b6d4", bg: "#ecfeff", border: "#a5f3fc" },
        warpLeadSkip:    { color: "#0f766e", bg: "#ecfdf5", border: "#5eead4" },
        pushOthersBack:  { color: "#f97316", bg: "#fff7ed", border: "#fed7aa" },
        shield2turn:     { color: "#4f46e5", bg: "#eef2ff", border: "#c7d2fe" },
        rerollHigher:    { color: "#10b981", bg: "#ecfdf5", border: "#6ee7b7" },
        randomPlusMinus3:{ color: "#ef4444", bg: "#fef2f2", border: "#fecaca" },
        warpMiddle:      { color: "#8b5cf6", bg: "#f5f3ff", border: "#ddd6fe" }
      };

      const priority = [
        "goldenTen",
        "doubleStep",
        "trapImmune",
        "extraTurn",
        "leadFollow",
        "swapLead",
        "warpLeadSkip",
        "pushOthersBack",
        "shield2turn",
        "rerollHigher",
        "randomPlusMinus3",
        "warpMiddle"
      ];

      let mainKey = null;
      for (const k of priority) {
        if (cheats[k]) {
          mainKey = k;
          break;
        }
      }

      if (!mainKey) {
        resetDiceStyle();
        cheatTextEl.style.color = "#4b5563";
        return;
      }

      const s = styleMap[mainKey];
      if (s) {
        const softGlow = hexToRgba(s.color, 0.6);
        diceVisualEl.style.borderColor = s.border;
        diceVisualEl.style.background = s.bg;
        diceVisualEl.style.color = s.color;
        diceVisualEl.style.boxShadow =
          `0 0 20px ${s.color}, 0 0 40px ${softGlow}`;
        cheatTextEl.style.color = s.color;
        diceVisualEl.classList.add("cheat-active");

        showCheatPopup(s, firedText, "ì¹˜íŠ¸", "âœ¨", 2000);
      } else {
        resetDiceStyle();
        cheatTextEl.style.color = "#4b5563";
      }
    }

    function updateStatusText() {
      if (players.length === 0) {
        currentPlayerEl.textContent = "-";
        currentPlayerEl.style.color = "#111827";
        positionsEl.textContent = "-";
        return;
      }

      const current = players[currentPlayerIndex];
      currentPlayerEl.textContent = current.name;
      currentPlayerEl.style.color = current.color;

      const posText = players
        .map((p) => `${p.name}: ${p.position}ì¹¸`)
        .join(" / ");
      positionsEl.textContent = posText;

      const pills = playersLegendEl.querySelectorAll(".player-pill");
      pills.forEach((pill, idx) => {
        pill.classList.toggle("current-turn", idx === currentPlayerIndex);
      });
    }

    function renderPlayersLegend() {
      playersLegendEl.innerHTML = "";
      players.forEach((p, idx) => {
        const pill = document.createElement("div");
        pill.className = "player-pill";
        pill.innerHTML = `
          <span class="player-dot" style="background:${p.color}"></span>
          <span>${p.name}</span>
        `;
        if (idx === currentPlayerIndex) {
          pill.classList.add("current-turn");
        }
        playersLegendEl.appendChild(pill);
      });
    }

    // ğŸ¨ ë³´ë“œ ê·¸ë¦¬ê¸° (ì´ˆê¸°í™” ë° í´ë¦­ ì´ë²¤íŠ¸ ë°”ì¸ë”©)
    function renderBoard() {
      boardEl.innerHTML = "";
      cellTokenEls.length = 0;

      for (let i = 0; i < BOARD_SIZE; i++) {
        const cell = document.createElement("div");
        cell.className = "cell";
        
        // í´ë¦­ ì´ë²¤íŠ¸ ì¶”ê°€ (ë§µ ì—ë””í„°ìš©)
        cell.addEventListener("click", () => handleCellClick(i));

        // í´ë˜ìŠ¤ ë¶€ì—¬
        const zone = findZone(i);
        const isReset = currentResetList.includes(i);
        const isGKey = currentGoldList.includes(i);

        if (zone) {
          if (zone.multiplier > 1) cell.classList.add("zone-boost");
          else if (zone.multiplier < 1) cell.classList.add("zone-slow");
        }
        if (isReset) cell.classList.add("zone-reset");
        if (isGKey) cell.classList.add("zone-gkey");

        let indexLabel = `${i}`;
        if (i === 0) {
          indexLabel = "ğŸš© ì¶œë°œ(0)";
          cell.classList.add("start-cell");
        } else if (i === BOARD_SIZE - 1) {
          indexLabel = `ğŸ ë„ì°©(${i})`;
          cell.classList.add("finish-cell");
        }

        const labels = [];
        if (zone && zone.multiplier !== 1) labels.push(`${zone.multiplier}ë°°`);
        if (isReset) labels.push("í•¨ì •");
        if (isGKey) labels.push("í™©ê¸ˆì—´ì‡ ");

        const labelText = labels.join(" / ");

        cell.innerHTML = `
          <div class="cell-index">${indexLabel}</div>
          <div class="cell-zone-label">${labelText}</div>
          <div class="token-container"></div>
        `;

        boardEl.appendChild(cell);
        const tokenContainer = cell.querySelector(".token-container");
        cellTokenEls.push(tokenContainer);
      }
    }

    function renderTokens() {
      cellTokenEls.forEach((el) => (el.innerHTML = ""));

      players.forEach((p, idx) => {
        const pos = p.position;
        if (pos < 0 || pos >= BOARD_SIZE) return;
        const container = cellTokenEls[pos];
        if (!container) return;

        const token = document.createElement("div");
        token.className = "token";
        token.style.background = p.color;
        token.title = p.name;

        if (idx === currentPlayerIndex) {
          token.classList.add("current-turn");
        }

        if (p.isFastMoving) {
          token.classList.add("token-fast");
        }

        container.appendChild(token);
      });
    }

    function cellsToText(arr) {
      if (!arr || arr.length === 0) return "ì—†ìŒ";
      return arr.join(", ") + "ë²ˆ ì¹¸";
    }

    // ğŸ› ï¸ ë§µ ë°ì´í„° ë™ê¸°í™” í•¨ìˆ˜
    function updateGameZonesFromInputs() {
        // ì…ë ¥ì°½ ê°’ ì½ê¸°
        currentX2List = parseCellList(x2CellsInput.value, BOARD_SIZE);
        currentHalfList = parseCellList(halfCellsInput.value, BOARD_SIZE);
        currentResetList = parseCellList(resetCellsInput.value, BOARD_SIZE);
        currentGoldList = parseCellList(gKeyCellsInput.value, BOARD_SIZE);

        // specialZones ì¬êµ¬ì„±
        specialZones = [];
        currentX2List.forEach((n) => {
            specialZones.push({ start: n, end: n, multiplier: 2, label: "x2 ì¹¸" });
        });
        currentHalfList.forEach((n) => {
            specialZones.push({ start: n, end: n, multiplier: 0.5, label: "1/2 ì¹¸" });
        });

        updateLegendText();
    }

    function updateLegendText() {
      boostRangeText.textContent = cellsToText(currentX2List);
      slowRangeText.textContent = cellsToText(currentHalfList);
      resetRangeText.textContent = currentResetList.length ? currentResetList.join(", ") + "ë²ˆ ì¹¸" : "ì—†ìŒ";
      gKeyRangeText.textContent = currentGoldList.length ? currentGoldList.join(", ") + "ë²ˆ ì¹¸" : "ì—†ìŒ";
    }

    // ğŸ› ï¸ ë§µ ì—ë””í„°: í´ë¦­ ì²˜ë¦¬
    function handleCellClick(index) {
        // ì‹œì‘/ë„ì°©ì ì€ ìˆ˜ì • ë¶ˆê°€
        if (index === 0 || index === BOARD_SIZE - 1) return;

        let selectedTool = 'none';
        for(const r of toolRadios) {
            if(r.checked) {
                selectedTool = r.value;
                break;
            }
        }

        if (selectedTool === 'none') return; // ì¼ë°˜ ëª¨ë“œì¼ ë• ë¬´ì‹œ

        // 1. ë‹¤ë¥¸ ì†ì„±ì´ ìˆìœ¼ë©´ ë¨¼ì € ì œê±° (ì¤‘ë³µ ë°©ì§€)
        // ex) x2ë¥¼ ëˆ„ë¥´ë©´ ê¸°ì¡´ í•¨ì •, 1/2 ë“±ì„ ì œê±°
        function removeFromArray(arr, val) {
            const idx = arr.indexOf(val);
            if(idx > -1) arr.splice(idx, 1);
        }

        // í˜„ì¬ ìƒíƒœë¥¼ ì„ì‹œ ë³€ìˆ˜ì— ë°˜ì˜
        // (ì´ë¯¸ ìœ„ì—ì„œ ì „ì—­ë³€ìˆ˜ë¡œ ê´€ë¦¬ ì¤‘ì´ë¯€ë¡œ, ì§ì ‘ ìˆ˜ì • í›„ Inputì— ë°˜ì˜)
        
        let targetList = null;
        let targetInput = null;

        if (selectedTool === 'x2') {
            targetList = currentX2List;
            targetInput = x2CellsInput;
            removeFromArray(currentHalfList, index);
            removeFromArray(currentResetList, index);
            removeFromArray(currentGoldList, index);
        } else if (selectedTool === 'half') {
            targetList = currentHalfList;
            targetInput = halfCellsInput;
            removeFromArray(currentX2List, index);
            removeFromArray(currentResetList, index);
            removeFromArray(currentGoldList, index);
        } else if (selectedTool === 'trap') {
            targetList = currentResetList;
            targetInput = resetCellsInput;
            removeFromArray(currentX2List, index);
            removeFromArray(currentHalfList, index);
            removeFromArray(currentGoldList, index);
        } else if (selectedTool === 'gold') {
            targetList = currentGoldList;
            targetInput = gKeyCellsInput;
            removeFromArray(currentX2List, index);
            removeFromArray(currentHalfList, index);
            removeFromArray(currentResetList, index);
        }

        // 2. í† ê¸€ ë¡œì§
        if (targetList) {
            const idx = targetList.indexOf(index);
            if (idx > -1) {
                targetList.splice(idx, 1); // ì´ë¯¸ ìˆìœ¼ë©´ ì œê±°
            } else {
                targetList.push(index);    // ì—†ìœ¼ë©´ ì¶”ê°€
                targetList.sort((a,b) => a-b);
            }
        }

        // 3. ëª¨ë“  Input ì—…ë°ì´íŠ¸ (ë‹¤ë¥¸ ë¦¬ìŠ¤íŠ¸ì—ì„œ ì œê±°ëœ ê²ƒë„ ë°˜ì˜í•´ì•¼ í•˜ë¯€ë¡œ)
        x2CellsInput.value = currentX2List.join(", ");
        halfCellsInput.value = currentHalfList.join(", ");
        resetCellsInput.value = currentResetList.join(", ");
        gKeyCellsInput.value = currentGoldList.join(", ");

        // 4. ê²Œì„ ë°ì´í„° ë° ë¹„ì£¼ì–¼ ê°±ì‹ 
        updateGameZonesFromInputs();
        
        // ì „ì²´ ë¦¬ë Œë”ë§ ëŒ€ì‹  í´ë˜ìŠ¤ë§Œ ì—…ë°ì´íŠ¸í•˜ë©´ ë” ë¶€ë“œëŸ½ì§€ë§Œ, 
        // í…ìŠ¤íŠ¸ ë¼ë²¨ ë³€ê²½ ë“± ë³µì¡í•˜ë¯€ë¡œ renderBoard()ë¥¼ í˜¸ì¶œí•˜ê³  í† í°ë§Œ ë‹¤ì‹œ ì–¹ëŠ”ë‹¤.
        // ìœ„ì¹˜ ì´ˆê¸°í™” ë°©ì§€ë¥¼ ìœ„í•´ renderBoardë§Œ í˜¸ì¶œ
        renderBoard();
        renderTokens();
    }
    
    // ğŸ› ï¸ ë„êµ¬ ì„ íƒ ì‹œ ì»¤ì„œ ìŠ¤íƒ€ì¼ ë³€ê²½
    toolRadios.forEach(radio => {
        radio.addEventListener('change', () => {
            gameContainerEl.classList.remove('editor-mode-x2', 'editor-mode-half', 'editor-mode-trap', 'editor-mode-gold');
            if(radio.value !== 'none') {
                gameContainerEl.classList.add(`editor-mode-${radio.value}`);
            }
        });
    });

    // ğŸ› ï¸ ì…ë ¥ì°½ì´ ì§ì ‘ ë³€ê²½ë˜ì—ˆì„ ë•Œë„ ë°˜ì˜
    [x2CellsInput, halfCellsInput, resetCellsInput, gKeyCellsInput].forEach(input => {
        input.addEventListener('change', () => {
            updateGameZonesFromInputs();
            renderBoard();
            renderTokens();
        });
    });


    function animateMove(player, steps, onComplete) {
      if (steps <= 0) {
        onComplete();
        return;
      }
      isAnimating = true;
      let moved = 0;

      function step() {
        if (moved >= steps) {
          isAnimating = false;

          const landingCell = boardEl.children[player.position];
          if (landingCell) {
            landingCell.classList.add("landing");
            setTimeout(() => {
              landingCell.classList.remove("landing");
            }, 350);
          }

          onComplete();
          return;
        }

        let newPos = player.position + 1;
        const finishPos = BOARD_SIZE - 1;
        if (newPos >= finishPos) newPos = finishPos;

        player.position = newPos;
        renderTokens();
        updateStatusText();
        moved++;

        if (player.position === finishPos || moved >= steps) {
          isAnimating = false;

          const landingCell = boardEl.children[player.position];
          if (landingCell) {
            landingCell.classList.add("landing");
            setTimeout(() => {
              landingCell.classList.remove("landing");
            }, 350);
          }

          onComplete();
          return;
        }

        setTimeout(step, 250);
      }

      step();
    }

    function showGoldenKeyPopup() {
      playSound("golden");

      goldenKeyOverlayEl.classList.remove("show");
      goldenKeyPopupEl.classList.remove("show");
      cheatPopupEl.classList.remove("show");

      if (popupTimerId !== null) {
        clearTimeout(popupTimerId);
        popupTimerId = null;
      }

      const durationMs = 2000;
      const seconds = durationMs / 1000;
      goldenKeyPopupEl.style.animationDuration = seconds + "s";
      goldenKeyOverlayEl.style.animationDuration = seconds + "s";

      void goldenKeyOverlayEl.offsetWidth;

      goldenKeyOverlayEl.classList.add("show");
      spawnSparkles("#facc15");
      goldenKeyPopupEl.classList.add("show");

      popupTimerId = setTimeout(() => {
        goldenKeyOverlayEl.classList.remove("show");
        goldenKeyPopupEl.classList.remove("show");
        const remain = goldenKeyOverlayEl.querySelectorAll(".sparkle");
        remain.forEach((el) => el.remove());
        popupTimerId = null;
      }, durationMs);
    }

    function grantRandomCheatFromGoldenKey(player) {
      if (!CHEAT_DEFS.length) return;
      const idx = Math.floor(Math.random() * CHEAT_DEFS.length);
      const picked = CHEAT_DEFS[idx];

      player.storedCheatCode = picked.code;

      const msg =
        `ğŸ”‘ í™©ê¸ˆì—´ì‡ ! í™©ê¸ˆì—´ì‡ : ë‹¤ìŒ í„´ì— íŠ¹ìˆ˜í•œ íš¨ê³¼ê°€ ì ìš©ë©ë‹ˆë‹¤. ` +
        `(ë‹¤ìŒ ${player.name}ì˜ ìê¸° í„´ì— 1íšŒ ìë™ ì ìš©) ` +
        `(ì½”ë“œ: ${picked.code}, ì¹˜íŠ¸: ${picked.name})`;
      log(msg);

      diceInfoEl.textContent = "í™©ê¸ˆì—´ì‡ : ë‹¤ìŒ í„´ì— íŠ¹ìˆ˜í•œ íš¨ê³¼ê°€ ì ìš©ë©ë‹ˆë‹¤.";

      showGoldenKeyPopup();
    }

    function useShield(player, context) {
      if (!player.shieldChargesRemaining || player.shieldChargesRemaining <= 0) return false;
      player.shieldChargesRemaining--;
      const usedCount = 2 - player.shieldChargesRemaining;
      const usedText = ` (2íšŒì¤‘ ${usedCount}ë²ˆ ì‚¬ìš©)`;

      let msg;
      switch (context) {
        case "trap":
          msg = `ğŸ›¡ ${player.name}ì´(ê°€) í•¨ì •ìœ¼ë¡œ ì¸í•œ í•´ë¡œìš´ íš¨ê³¼ë¥¼ ë°©ì–´í–ˆìŠµë‹ˆë‹¤.${usedText}`;
          break;
        case "swap":
          msg = `ğŸ›¡ ${player.name}ì´(ê°€) ìë¦¬ êµí™˜ìœ¼ë¡œ ì¸í•œ í•´ë¡œìš´ íš¨ê³¼ë¥¼ ë°©ì–´í–ˆìŠµë‹ˆë‹¤.${usedText}`;
          break;
        case "pushBack":
          msg = `ğŸ›¡ ${player.name}ì´(ê°€) ë’¤ë¡œ ë°€ë¦¬ëŠ” í•´ë¡œìš´ íš¨ê³¼ë¥¼ ë°©ì–´í–ˆìŠµë‹ˆë‹¤.${usedText}`;
          break;
        case "minus3":
          msg = `ğŸ›¡ ${player.name}ì´(ê°€) -3ì¹¸ ì´ë™ í•´ë¡œìš´ íš¨ê³¼ë¥¼ ë°©ì–´í–ˆìŠµë‹ˆë‹¤.${usedText}`;
          break;
        default:
          msg = `ğŸ›¡ ${player.name}ì´(ê°€) í•´ë¡œìš´ íš¨ê³¼ë¥¼ ë°©ì–´í–ˆìŠµë‹ˆë‹¤.${usedText}`;
      }
      log(msg);

      const popupLabel = `í•´ë¡œìš´ íš¨ê³¼ê°€ ë¬´íš¨í™”ë˜ì—ˆìŠµë‹ˆë‹¤. (2íšŒì¤‘ ${usedCount}ë²ˆ ì‚¬ìš©)`;
      showCheatPopup(
        { color: "#bbf7d0", bg: "#064e3b" },
        popupLabel,
        "ë°©ì–´",
        "ğŸ›¡",
        2000
      );

      return true;
    }

    function afterMoveCheck(player, cheats) {
      renderTokens();
      updateStatusText();

      const finishPos = BOARD_SIZE - 1;

      if (player.position === finishPos) {
        playSound("win");
        log(`ğŸ‰ ${player.name}ì´(ê°€) ë„ì°© ì§€ì ì— ë¨¼ì € ë„ë‹¬í–ˆìŠµë‹ˆë‹¤! ê²Œì„ ì¢…ë£Œ!`);
        diceInfoEl.textContent = `${player.name} ìŠ¹ë¦¬! ê²Œì„ì´ ëë‚¬ìŠµë‹ˆë‹¤.`;
        gameOver = true;
        rollBtn.disabled = true;
        skipBtn.disabled = true;
        isRollingDice = false;
        isAnimating = false;
        return;
      }

      if (cheats.trapImmune) {
        player.trapImmune = true;
        log(`ğŸ§² ì¹˜íŠ¸: ${player.name}ì´(ê°€) ë‚¨ì€ ê²Œì„ ë™ì•ˆ í•¨ì • ì¹¸ì„ ëª¨ë‘ ë¬´ì‹œí•©ë‹ˆë‹¤.`);
      }

      if (cheats.shield2turn) {
        player.shieldChargesRemaining = 2;
        log(`ğŸ›¡ ì¹˜íŠ¸: ${player.name}ì´(ê°€) í•´ë¡œìš´ íš¨ê³¼ë¥¼ 2ë²ˆê¹Œì§€ ë§‰ì•„ì£¼ëŠ” ë³´í˜¸ë§‰ì„ ì–»ì—ˆìŠµë‹ˆë‹¤.`);
      }

      if (currentResetList.includes(player.position)) {
        const trapPos = player.position;

        if (player.trapImmune) {
          log(`ğŸ§² í•¨ì • ì¹¸(${trapPos})ì— ë„ì°©í–ˆì§€ë§Œ, í•¨ì • ë¬´ì‹œ íš¨ê³¼ë¡œ ì•ˆì „í•©ë‹ˆë‹¤.`);
        } else if (player.shieldChargesRemaining && player.shieldChargesRemaining > 0) {
          useShield(player, "trap");
        } else {
          log(`âš  ${player.name}ì´(ê°€) í•¨ì • ì¹¸(${trapPos})ì— ë„ì°©í•˜ì—¬ ì¶œë°œì ìœ¼ë¡œ ë˜ëŒì•„ê°‘ë‹ˆë‹¤.`);

          showCheatPopup(
            { color: "#fee2e2", bg: "#111827" },
            `í•¨ì • ì¹¸(${trapPos})! ì¶œë°œì ìœ¼ë¡œ ë˜ëŒì•„ê°‘ë‹ˆë‹¤.`,
            "í•¨ì •",
            "âš ",
            2000
          );

          if (gameContainerEl) {
            gameContainerEl.classList.add("shake");
            setTimeout(() => {
              gameContainerEl.classList.remove("shake");
            }, 400);
          }

          player.position = 0;
          renderTokens();
          updateStatusText();
        }
      }

      if (cheats.leadFollow) {
        let maxPos = -1;
        players.forEach((pl) => {
          if (pl.position > maxPos) maxPos = pl.position;
        });
        if (maxPos > 0) {
          const target = Math.max(0, Math.min(maxPos - 1, finishPos));
          if (target > player.position) {
            log(`ğŸƒ ì¹˜íŠ¸: ${player.name}ì´(ê°€) ì„ ë‘ ë°”ë¡œ ë’¤ ì¹¸(${target})ìœ¼ë¡œ ì´ë™í–ˆìŠµë‹ˆë‹¤.`);
            player.position = target;
            renderTokens();
            updateStatusText();
          } else {
            log("ğŸƒ ì¹˜íŠ¸: ì´ë¯¸ ì„ ë‘ì— ê°€ê¹Œì›Œ íš¨ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.");
          }
        }
      }

      if (cheats.swapLead) {
        let leader = players[0];
        players.forEach((pl) => {
          if (pl.position > leader.position) leader = pl;
        });

        if (leader === player) {
          log("ğŸ”„ ì¹˜íŠ¸: ì´ë¯¸ ì„ ë‘ë¼ êµí™˜ íš¨ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.");
        } else if (leader.shieldChargesRemaining && leader.shieldChargesRemaining > 0) {
          useShield(leader, "swap");
        } else {
          const tmp = player.position;
          player.position = leader.position;
          leader.position = tmp;
          log(`ğŸ”„ ì¹˜íŠ¸: ${player.name}ê³¼(ì™€) ${leader.name}ì˜ ìœ„ì¹˜ë¥¼ êµí™˜í–ˆìŠµë‹ˆë‹¤.`);
          renderTokens();
          updateStatusText();
        }
      }

      if (cheats.pushOthersBack) {
        players.forEach((pl) => {
          if (pl === player) return;
          if (pl.position > 0) {
            if (pl.shieldChargesRemaining && pl.shieldChargesRemaining > 0) {
              useShield(pl, "pushBack");
            } else {
              pl.position = pl.position - 1;
            }
          }
        });
        log(`â¬… ì¹˜íŠ¸: ${player.name}ì„(ë¥¼) ì œì™¸í•œ ë‹¤ë¥¸ í”Œë ˆì´ì–´ê°€ 1ì¹¸ì”© ë’¤ë¡œ ë°€ë ¸ìŠµë‹ˆë‹¤.`);
        renderTokens();
        updateStatusText();
      }

      if (cheats.randomPlusMinus3) {
        const sign = Math.random() < 0.5 ? -1 : 1;
        const delta = 3 * sign;

        if (delta < 0 && player.shieldChargesRemaining && player.shieldChargesRemaining > 0) {
          useShield(player, "minus3");
        } else {
          const before = player.position;
          let after = before + delta;
          if (after < 0) after = 0;
          if (after > finishPos) after = finishPos;
          log(`ğŸ² ì¹˜íŠ¸: ${delta > 0 ? "+3" : "-3"}ì¹¸ ì´ë™ìœ¼ë¡œ ${before} â†’ ${after}`);
          player.position = after;
          renderTokens();
          updateStatusText();
        }
      }

      if (cheats.warpMiddle) {
        const middle = Math.floor(finishPos / 2);
        if (player.position !== middle) {
          log(`âœ¨ ì¹˜íŠ¸: ${player.name}ì´(ê°€) ì¤‘ì•™ ì¹¸(${middle})ìœ¼ë¡œ ì›Œí”„í–ˆìŠµë‹ˆë‹¤.`);
          player.position = middle;
          renderTokens();
          updateStatusText();
        } else {
          log("âœ¨ ì¹˜íŠ¸: ì´ë¯¸ ì¤‘ì•™ ì¹¸ì— ìˆì–´ íš¨ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.");
        }
      }

      if (cheats.warpLeadSkip) {
        let leader = players[0];
        players.forEach((pl) => {
          if (pl.position > leader.position) leader = pl;
        });

        if (leader === player) {
          log("ğŸ”¥ ì¹˜íŠ¸: ì´ë¯¸ ì„ ë‘ë¼ ì„ ë‘ ì›Œí”„ íš¨ê³¼ê°€ ì—†ìŠµë‹ˆë‹¤.");
        } else {
          const target = leader.position;
          log(`ğŸ”¥ ì¹˜íŠ¸: ${player.name}ì´(ê°€) ì„ ë‘ ìœ„ì¹˜(${target})ë¡œ ì›Œí”„í•©ë‹ˆë‹¤. (ë‹¤ìŒ ìê¸° ì°¨ë¡€ëŠ” ìë™ ìŠ¤í‚µ)`);
          player.position = target;
          renderTokens();
          updateStatusText();
          player.skipTurnsRemaining = (player.skipTurnsRemaining || 0) + 1;
        }
      }

      if (player.position === finishPos) {
        playSound("win");
        log(`ğŸ‰ ${player.name}ì´(ê°€) ì¹˜íŠ¸ íš¨ê³¼ë¡œ ë„ì°© ì§€ì ì— ë„ë‹¬í–ˆìŠµë‹ˆë‹¤! ê²Œì„ ì¢…ë£Œ!`);
        diceInfoEl.textContent = `${player.name} ìŠ¹ë¦¬! ê²Œì„ì´ ëë‚¬ìŠµë‹ˆë‹¤.`;
        gameOver = true;
        rollBtn.disabled = true;
        skipBtn.disabled = true;
        isRollingDice = false;
        isAnimating = false;
        return;
      }

      if (currentGoldList.includes(player.position)) {
        grantRandomCheatFromGoldenKey(player);
      }

      if (cheats.extraTurn) {
        log(`ğŸ” ì¹˜íŠ¸ íš¨ê³¼ë¡œ ${player.name}ì´(ê°€) í•œ ë²ˆ ë” í„´ì„ ì–»ì—ˆìŠµë‹ˆë‹¤.`);
        isRollingDice = false;
        rollBtn.disabled = false;
        skipBtn.disabled = false;
        updateStatusText();
        return;
      }

      currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
      renderTokens();
      updateStatusText();
      isRollingDice = false;
      rollBtn.disabled = false;
      skipBtn.disabled = false;
    }

    function performMove(roll, cheats) {
      if (players.length === 0) return;
      const player = players[currentPlayerIndex];
      const startPos = player.position;
      const { multiplier, label } = getMultiplierInfo(startPos);

      if ((!cheats.triggered || cheats.triggered.length === 0) && multiplier !== 1) {
        const isBoost = multiplier > 1;
        const style = isBoost
          ? { color: "#fed7aa", bg: "#7c2d12" }
          : { color: "#bfdbfe", bg: "#020617" };
        const prefix = isBoost ? "x2 ë°°ì†" : "1/2 ë°°ì†";
        const msg = isBoost ? "ë¹ ë¥´ê²Œ ì „ì§„í•©ë‹ˆë‹¤!" : "ëŠë¦¬ê²Œ ì´ë™í•©ë‹ˆë‹¤.";
        const icon = isBoost ? "âš¡" : "ğŸ¢";
        showCheatPopup(style, msg, prefix, icon, 2000);
      }

      let extraFactor = cheats.doubleStep ? 2 : 1;
      if (cheats.doubleStep) {
        log("ğŸš€ ì¹˜íŠ¸ë¡œ ì´ë²ˆ ì´ë™ ê±°ë¦¬ê°€ 2ë°°ê°€ ë©ë‹ˆë‹¤.");
      }

      const isFast = (multiplier > 1) || cheats.doubleStep;
      player.isFastMoving = isFast;

      const effectiveSteps = Math.floor(roll * multiplier * extraFactor);

      const finishPos = BOARD_SIZE - 1;
      let targetPos = startPos + effectiveSteps;
      if (targetPos >= finishPos) targetPos = finishPos;
      const stepsToMove = targetPos - startPos;

      const baseMsg = `${player.name}ì´(ê°€) ì£¼ì‚¬ìœ„ ${roll}ì´(ê°€) ë‚˜ì™”ìŠµë‹ˆë‹¤. (${label})`;
      const moveMsg =
        stepsToMove <= 0
          ? `ë°°ìˆ˜ ì ìš© í›„ ì´ë™ ì¹¸: 0ì¹¸ (ì œìë¦¬)`
          : `ë°°ìˆ˜ ì ìš© í›„ ì´ë™ ì¹¸: ${stepsToMove}ì¹¸ â†’ ${startPos} â†’ ${targetPos}`;
      diceInfoEl.textContent = `${baseMsg} / ${moveMsg}`;
      log(`${baseMsg} ${moveMsg}`);

      if (stepsToMove <= 0) {
        player.isFastMoving = false;
        renderTokens();
        afterMoveCheck(player, cheats);
      } else {
        animateMove(player, stepsToMove, () => {
          player.isFastMoving = false;
          renderTokens();
          afterMoveCheck(player, cheats);
        });
      }
    }

    // ğŸ² ì£¼ì‚¬ìœ„ êµ´ë¦¬ê¸°
    function startRoll() {
      if (gameOver || isAnimating || isRollingDice || players.length === 0) return;

      const player = players[currentPlayerIndex];
      if (player.skipTurnsRemaining && player.skipTurnsRemaining > 0) {
        player.skipTurnsRemaining--;
        log(`â­ï¸ ì¹˜íŠ¸ íš¨ê³¼ë¡œ ${player.name}ì˜ í„´ì´ ìë™ìœ¼ë¡œ ìŠ¤í‚µë©ë‹ˆë‹¤.`);
        currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
        renderTokens();
        updateStatusText();
        return;
      }

      const cheats = getCheatsForCurrentRoll();
      showCheatText(cheats);

      const hasCheat = cheats.triggered && cheats.triggered.length > 0;

      // ì¹˜íŠ¸ê°€ ì—†ì„ ë•Œ â†’ ë§ ìƒ‰ê¹” ê¸°ë°˜ ì—°í•œ ë„¤ì˜¨
      if (!hasCheat && player) {
        resetDiceStyle();
        setDiceNeonForColor(player.color);
      }

      if (!hasCheat) {
        playSound("dice");
      }

      isRollingDice = true;
      rollBtn.disabled = true;
      skipBtn.disabled = true;

      diceVisualEl.classList.remove("rolling");
      void diceVisualEl.offsetWidth;
      diceVisualEl.classList.add("rolling");

      let ticks = 0;
      const maxTicks = 10;
      const intervalMs = 80;

      const intervalId = setInterval(() => {
        const tempRoll = Math.floor(Math.random() * 6) + 1;
        setDiceFace(tempRoll);
        ticks++;
        if (ticks >= maxTicks) {
          clearInterval(intervalId);

          let finalRoll;
          if (cheats.goldenTen) {
            finalRoll = 15;
            log("âœ¨ ì¹˜íŠ¸: í™©ê¸ˆ ì£¼ì‚¬ìœ„(15)ê°€ ì ìš©ë˜ì—ˆìŠµë‹ˆë‹¤.");
          } else if (cheats.rerollHigher) {
            const r1 = Math.floor(Math.random() * 6) + 1;
            const r2 = Math.floor(Math.random() * 6) + 1;
            finalRoll = Math.max(r1, r2);
            log(`ğŸ² ì¹˜íŠ¸: ì¬êµ´ë¦¼ (${r1}, ${r2}) ì¤‘ ${finalRoll} ì‚¬ìš©.`);
          } else {
            finalRoll = Math.floor(Math.random() * 6) + 1;
          }

          setDiceFace(finalRoll);
          performMove(finalRoll, cheats);

          secretCodeInput.value = "";
        }
      }, intervalMs);
    }

    function skipTurn() {
      if (gameOver || isAnimating || isRollingDice || players.length === 0) return;

      const player = players[currentPlayerIndex];

      if (player.skipTurnsRemaining && player.skipTurnsRemaining > 0) {
        player.skipTurnsRemaining--;
        log(`â­ï¸ ì¹˜íŠ¸ íš¨ê³¼ë¡œ ${player.name}ì˜ í„´ì´ ìë™ìœ¼ë¡œ ìŠ¤í‚µë©ë‹ˆë‹¤.`);
      } else {
        log(`â­ï¸ ${player.name}ì´(ê°€) ì´ë²ˆ í„´ì„ ê±´ë„ˆëœë‹ˆë‹¤.`);
      }

      currentPlayerIndex = (currentPlayerIndex + 1) % players.length;
      renderTokens();
      updateStatusText();
    }

    function setupGame() {
      let sizeVal = parseInt(boardSizeInput.value, 10);
      if (isNaN(sizeVal) || sizeVal < 6) sizeVal = 30;
      BOARD_SIZE = Math.max(6, Math.min(sizeVal, 200));

      // ì…ë ¥ê°’ ë¡œë“œ ë° ì´ˆê¸°í™”
      updateGameZonesFromInputs();

      const count = parseInt(playerCountSelect.value, 10);
      players = [];
      for (let i = 0; i < count; i++) {
        players.push({
          name: `í”Œë ˆì´ì–´ ${i + 1}`,
          position: 0,
          color: PLAYER_COLORS[i % PLAYER_COLORS.length],
          shieldChargesRemaining: 0,
          skipTurnsRemaining: 0,
          trapImmune: false,
          storedCheatCode: null,
          isFastMoving: false
        });
      }

      currentPlayerIndex = 0;
      gameOver = false;
      isAnimating = false;
      isRollingDice = false;

      renderBoard();
      renderTokens();
      renderPlayersLegend();
      updateStatusText();

      logEl.innerHTML = "";
      diceVisualEl.textContent = "-";
      resetDiceStyle();
      diceInfoEl.textContent = "ğŸ² ì£¼ì‚¬ìœ„ë¥¼ êµ´ë ¤ ê²Œì„ì„ ì‹œì‘í•´ ë³´ì„¸ìš”.";
      secretCodeInput.value = "";
      cheatTextEl.textContent = "ì¹˜íŠ¸: ì—†ìŒ";
      cheatTextEl.style.color = "#4b5563";
      rollBtn.disabled = false;
      skipBtn.disabled = false;

      // ë„êµ¬ ì´ˆê¸°í™” (ì„ íƒ/ì´ë™ìœ¼ë¡œ)
      document.getElementById('tool-none').checked = true;
      gameContainerEl.classList.remove('editor-mode-x2', 'editor-mode-half', 'editor-mode-trap', 'editor-mode-gold');

      applyTheme(themeSelect.value);
    }

    rollBtn.addEventListener("click", () => {
      startRoll();
    });

    skipBtn.addEventListener("click", () => {
      playSound("click");
      skipTurn();
    });

    startBtn.addEventListener("click", () => {
      playSound("click");
      setupGame();
    });

    themeSelect.addEventListener("change", (e) => {
      applyTheme(e.target.value);
    });

    applyTheme(themeSelect.value);
    setupGame();
  </script>
</body>
</html>